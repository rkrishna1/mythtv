#include "imagehandlers.h"

#include "imageutils.h"
#include "imagemetadata.h"
#include "imagescanner.h"
#include "imagethumbs.h"


/*!
 \brief Change name of an image/dir
 \details Renames image/dir in Photographs storage group, synchronises image database
 and thumbnail cache and notifies clients. A new thumbnail will be generated by next client
 request.
 \param id File/dir id
 \param newBase New filename
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleRename(QString id, QString newBase)
{
    // Sanity check new name
    if (newBase.isEmpty() || newBase.contains("/") || newBase.contains("\\"))
        return QStringList("ERROR") << "Invalid name";

    // Find image in DB
    ImageDbWriter db;
    ImageList images, dirs;
    db.ReadDbItemsById(images, id);

    // Either single id not found or multiple comma-delimited ids received
    if (images.size() != 1)
    {
        LOG(VB_FILE, LOG_NOTICE,
            QString("Image: Image %1 not found in Db").arg(id));
        qDeleteAll(images);
        return QStringList("ERROR") << "Unknown File";
    }

    // Get filepath for solitary image
    ImageItem *im = images[0];
    QString absFilename = ImageSg::getInstance()->GetFilePath(im);

    if (absFilename.isEmpty())
    {
        delete im;
        return QStringList("ERROR") << "File not found";
    }

    // Rename file
    QFileInfo info = QFileInfo(absFilename);
    QDir dir = info.absoluteDir();
    QString newName = im->IsDirectory()
            ? newBase : QString("%1.%2").arg(newBase, info.suffix());

    if (!dir.rename(im->m_name, newName))
    {
        LOG(VB_FILE, LOG_ERR, QString("Image: Rename of %1 -> %2 failed")
            .arg(im->m_name, newName));
        delete im;
        return QStringList("ERROR") << "Rename failed";
    }

    LOG(VB_FILE, LOG_DEBUG, QString("Image: Renamed %1 -> %2")
        .arg(im->m_fileName, newName));

    ImageList dummy;

    if (im->IsDirectory())
    {
        // Cleanup thumbdir/thumbnails
        // Thumb generator now owns the image object
        QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(dummy, images);

        // Notify clients of deleted ids, images, thumbs
        gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));

        // Dir name change affects path of all sub-dirs & files and their thumbs
        QStringList scan;
        scan << "IMAGE_SCAN" << "START";
        return ImageScan::getInstance()->HandleScanRequest(scan);
    }

    // Retain old image for cleanup
    ImageItem *newIm = new ImageItem(*im);

    // Update db
    newIm->m_name = newName;
    newIm->m_fileName = QDir::cleanPath(QDir(newIm->m_path).filePath(newName));
    db.UpdateDbFile(newIm);
    delete newIm;

    // Clean up thumbnail
    // Thumb generator now owns the images objects
    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, dummy);
    // Item is modified, not deleted
    mesg.swap(0,1);

    // New thumbnail will be created by client request

    // Notify clients of changed image & thumbnail
    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));

    return QStringList("OK");
}


/*!
 \brief Deletes images/dirs
 \details Removes images/dirs from Photographs storage group and image database.
 Dirs will only be deleted if empty. Synchronises thumbnail cache and broadcasts
 a 'db changed' event. Only fails if nothing is deleted.
 \param fileIds Csv list of dir/file ids
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleDelete(QString fileIds)
{
    // Get subtree of files
    ImageDbWriter db;
    ImageList images, dirs;
    db.ReadDbTree(images, dirs, fileIds.split(","));

    // Remove files from filesystem first
    ImageSg::getInstance()->RemoveFiles(images);
    // ... then dirs, which should now be empty
    ImageSg::getInstance()->RemoveFiles(dirs);

    // Fail if nothing deleted
    if (images.isEmpty() && dirs.isEmpty())
        return QStringList("ERROR") << "Delete failed";

    // Update Db
    db.RemoveFromDB(images + dirs);

    // Clean up thumbnails & update clients
    // Thumb generator now owns the image objects
    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, dirs);

    // Notify clients of deleted ids, images, thumbs
    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));

    return QStringList("OK");
}


/*!
 \brief Gets meta data for an image
 \details Reads exif tags from a picture or FFMPEG video tags
 \param id Image id
 \return QStringList Error message or "OK", seperator,
list of <tag name><seperator><tag value>.
Clients must use the embedded seperator to extract the data.
*/
QStringList ImageHandler::HandleGetMetadata(QString id)
{
    // Find image in DB
    ImageDbWriter db;
    ImageList images;
    db.ReadDbFilesById(images, id);

    // Either single id not found or multiple comma-delimited ids received
    if (images.size() != 1)
    {
        LOG(VB_FILE, LOG_NOTICE,
            QString("Image: Image %1 not found in Db").arg(id));
        qDeleteAll(images);
        return QStringList("ERROR") << "Unknown File";
    }

    // Read all metadata tags
    ImageMetaData::TagMap tags;
    QStringList result;

    if (ImageMetaData::GetMetaData(images[0], tags))
    {
        // Each property is described by a pair of <tagvalue> : <taglabel>
        // Combine label/value using a (hopefully unique) delimiter
        // to return 1 string per property.
        const QString seperator = ":|-|:";
        result << "OK" << seperator;

        foreach (const ImageMetaData::TagPair value, tags)
        {
            result.append(QString("%1%2%3")
                          .arg(value.second).arg(seperator).arg(value.first));
        }
    }
    else
    {
        result = QStringList("ERROR") << QString("No metadata");
    }
    qDeleteAll(images);

    return result;
}


/*!
 \brief Moves image trees
 \details Moves a list of images/dirs to an existing image dir. Renames files in
 the Photographs storage group and rescans to synchronise db and thumbnail cache
 and update clients. Only fails if nothing is moved.
 \param destId destination dir id
 \param ids Csv list of dir/file ids
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleMove(QString destId, QString ids)
{
    // Validate destination
    ImageList destDir;
    ImageDbWriter db;
    db.ReadDbDirsById(destDir, destId);

    // Either single id not found or multiple comma-delimited ids received
    if (destDir.size() != 1)
    {
        LOG(VB_FILE, LOG_ERR,
            QString("IMAGE_MOVE: Dir %1 not found in Db").arg(destId));
        qDeleteAll(destDir);
        return QStringList("ERROR") << "Missing destination";
    }

    // Get transferees
    ImageList images;
    db.ReadDbItemsById(images, ids);

    bool changed = ImageSg::getInstance()->MoveFiles(images, destDir[0]);

    delete destDir[0];
    qDeleteAll(images);

    if (!changed)
        return QStringList("ERROR") << "Move failed";

    // Rescan to update Db & clients
    QStringList scan;
    scan << "IMAGE_SCAN" << "START";
    return ImageScan::getInstance()->HandleScanRequest(scan);
}


/*!
 \brief Hides/unhides images/dirs
 \details Updates hidden status in image database and updates clients
 \param hide hide flag: 0 = Show, 1 = Hide
 \param fids Csv list of file/dir ids
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleHide(bool hide, QString fids)
{
    // Extract ids
    QStringList fileIds = fids.split(",", QString::SkipEmptyParts);

    ImageDbWriter db;
    if (!db.SetHidden(hide, fileIds))
        return QStringList("ERROR") << "Hide failed";

    LOG(VB_FILE, LOG_DEBUG, QString("Image: Nodes %1 now %2hidden")
        .arg(fids, hide ? "" : "un"));

    // Send changed ids only (none deleted)
    QStringList mesg = QStringList("") << fids;
    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));

    return QStringList("OK");
}

/*!
 \brief Change orientation of pictures by applying a transformation
 \details Updates picture exif and image database, removes obselete thumbnails and
 updates clients. New thumbnails will be generated by client request. Only fails if
 nothing is modified.
 \param transform transformation id,
 \param fileIds Csv list of file ids
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleTransform(int transform, QString fileIds)
{
    if (transform < kResetExif || transform > kFlipVertical)
        return QStringList("ERROR") << "Bad IMAGE_TRANSFORM transform";

    if (fileIds.isEmpty())
        return QStringList("ERROR") << "Empty IMAGE_TRANSFORM";

    ImageDbWriter db;
    ImageList images;
    db.ReadDbFilesById(images, fileIds);

    // Update db
    foreach (ImageItem *im, images)
    {
        if (transform == kResetExif)
        {
            ImageMetaData::PopulateMetaValues(im);
        }
        else
        {
            // Apply transform to this image
            im->m_orientation = ExifOrientation::Transformed(im->m_orientation,
                                                             transform);
        }
        db.SetOrientation(im);
    }

    // Clean up thumbnails & update clients
    // Thumb generator now owns the image objects
    ImageList noDirs;
    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, noDirs);

    // Swap ids from 'deleted' to 'changed'
    mesg.swap(0,1);
    // Notify clients of changed images, thumbs
    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));

    return QStringList("OK");
}

/*!
 \brief Creates a new image dirs
 \details Creates dirs in Photographs storage group 'most free' path. Only fails if
 no new dirs are created. Other clients are not notified.
 \param names Csv list of dir names
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleDirs(QStringList names)
{
    // Note: Could/should be implemented by RemoteFile

    // Get SG dir
    QString sgDir = ImageSg::getInstance()->m_sgImages.FindNextDirMostFree();
    if (sgDir.isEmpty())
        return QStringList("ERROR") << "Empty Storage Group";

    bool success = false;
    QDir dir;
    for (int i = 0; i < names.size(); ++i)
    {
        if (dir.mkpath(QString("%1/%2").arg(sgDir, names[i])))
            success = true;
        else
            LOG(VB_FILE, LOG_ERR, QString("Image: Failed to create dir %1")
                .arg(names[i]));
    }

    return success ? QStringList("OK")
                   : QStringList("ERROR") << "Create failed";
}

/*!
 \brief Updates/resets cover thumbnail for an image dir
 \details Notifies all clients of new cover
 \param dir Directory id
 \param Cover Id of 0 resets dir to use its own thumbnail
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleCover(int dir, int cover)
{
    ImageDbWriter db;
    db.SetCover(dir, cover);

    LOG(VB_FILE, LOG_DEBUG, QString("Image: Cover of %1 is now %2")
        .arg(dir).arg(cover));

    // Id has changed, nothing deleted
    QStringList mesg = QStringList("") << QString::number(dir);
    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));

    return QStringList("OK");
}

/*!
 \brief Updates exclusion list for images
 \details Stores new exclusions setting & rescans. Exclusions is a global setting
 that dictates which files the scanner ignores. However it is set by any client
 (last writer wins). Glob characters * and ? are valid.
 \param exclusions Csv list of exclusion patterns
 \return QStringList Error message or "OK"
*/
QStringList ImageHandler::HandleIgnore(QString exclusions)
{
    // Save new setting. FE will have already saved it but not cleared the cache
    gCoreContext->SaveSettingOnHost("GalleryIgnoreFilter", exclusions, NULL);

    // Rescan
    QStringList scan;
    scan << "IMAGE_SCAN" << "START";
    ImageScan *is = ImageScan::getInstance();
    return is->HandleScanRequest(scan);
}

